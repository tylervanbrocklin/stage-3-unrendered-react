{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');\n\nvar _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _after = require('./after');\n\nvar _after2 = _interopRequireDefault(_after);\n\nvar _options2 = require('./options');\n\nvar _options3 = _interopRequireDefault(_options2);\n\nvar _browser = require('./util/browser');\n\nvar _browser2 = _interopRequireDefault(_browser);\n\nvar _test = require('./test');\n\nvar _test2 = _interopRequireDefault(_test);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar A11y = function () {\n  /**\n   * @arg {object} React    - The React instance you want to patch\n   * @arg {object} ReactDOM - The ReactDOM instance you'll be using\n   * @arg {object} options  - the options\n   * @returns {A11y} The react-a11y instance\n   */\n  function A11y() {\n    (0, _classCallCheck3.default)(this, A11y);\n\n    var _validate = _options3.default.apply(undefined, arguments),\n        React = _validate.React,\n        ReactDOM = _validate.ReactDOM,\n        options = (0, _objectWithoutProperties3.default)(_validate, ['React', 'ReactDOM']);\n\n    this.options = options;\n    this.React = React;\n    this.ReactDOM = ReactDOM;\n    this.suite = new _test2.default(React, ReactDOM, this.options);\n    this.patchReact();\n  }\n  /**\n   * Patch React, replacing its createElement by our implementation\n   * so we can run the tests\n   * @returns {undefined}\n   */\n\n\n  (0, _createClass3.default)(A11y, [{\n    key: 'patchReact',\n    value: function patchReact() {\n      // save old createElement\n      this._createElement = this.React.createElement;\n\n      var _this = this;\n\n      this.React.createElement = function (klass) {\n        var _props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // fix for props = null\n\n\n        var props = _props || {}; // create a refs object to hold the ref.\n        // this needs to be an object so that it can be passed\n        // by reference, and hold changing state.\n\n        var refs = typeof props.ref === 'string' || (0, _typeof3.default)(props.ref) === 'object' ? props.ref : {};\n        var ref = typeof props.ref === 'string' || (0, _typeof3.default)(props.ref) === 'object' ? props.ref : function (node) {\n          refs.node = node; // maintain behaviour when ref prop was already set\n\n          if (typeof props.ref === 'function') {\n            props.ref(node);\n          }\n        };\n        var newProps = typeof klass === 'string' ? (0, _extends3.default)({}, props, {\n          ref: ref\n        }) : props;\n\n        for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          children[_key - 2] = arguments[_key];\n        }\n\n        var reactEl = _this._createElement.apply(_this, [klass, newProps].concat(children)); // only test html elements\n\n\n        if (typeof klass === 'string') {\n          var handler = _this.failureHandler(reactEl, refs);\n\n          var childrenForTest = children.length === 0 ? props.children || [] : children;\n\n          _this.suite.test(klass, props, childrenForTest, handler);\n        }\n\n        return reactEl;\n      };\n    }\n    /**\n     * Restore React and all components as if we were never here\n     * @returns {undefined}\n    */\n\n  }, {\n    key: 'restoreAll',\n    value: function restoreAll() {\n      this.React.createElement = this._createElement;\n\n      _after2.default.restorePatchedMethods();\n    }\n    /**\n     * Creates a failure handler based on the element that was created\n     * @arg {object} reactEl - The react element this failure is for\n     * @arg {object} ref     - The object that holds the DOM node (passed by ref)\n     * @returns {function} A handler that knows everything it needs to know\n     */\n\n  }, {\n    key: 'failureHandler',\n    value: function failureHandler(reactEl, ref) {\n      var _options = this.options,\n          reporter = _options.reporter,\n          filterFn = _options.filterFn;\n      /**\n       * @arg {string} errInfo  - All the error info (see docs what this means)\n       * @returns {undefined}\n       */\n\n      return function (errInfo) {\n        // get the owning component (the one that has\n        // the element in its render fn)\n        var owner = reactEl._owner; // if there is an owner, use its name\n        // if not, use the tagname of the violating elemnent\n\n        var displayName = '';\n\n        if (owner) {\n          displayName = owner.type ? owner.type.name : owner.getName();\n        } else {\n          displayName = errInfo.tagName + '#' + errInfo.props.id;\n        } // stop if we're not allowed to proceed\n\n\n        if (!filterFn(displayName, errInfo.props.id, errInfo.msg)) {\n          return;\n        } // gather all info for the reporter\n\n\n        var info = (0, _extends3.default)({}, errInfo, {\n          displayName: displayName\n        });\n        var DOMNode = false;\n\n        if (_browser2.default && !this.__sync) {\n          // Make a best-effort attempt to grab the DOMNode\n          var instance = owner && owner._instance;\n\n          if (owner && owner.stateNode) {\n            // Fiber\n            DOMNode = this.ReactDOM.findDOMNode(owner.stateNode);\n          } else if (typeof ref === 'string' && instance) {\n            DOMNode = this.ReactDOM.findDOMNode(instance.refs[ref]); // TODO: replace use of findDOMNode\n          } else if ('node' in ref) {\n            DOMNode = ref.node;\n          }\n        }\n\n        if (DOMNode) {\n          reporter((0, _extends3.default)({}, info, {\n            DOMNode: DOMNode\n          }));\n        } else {\n          reporter(info);\n        }\n      }.bind(this);\n    }\n  }]);\n  return A11y;\n}();\n\nexports.default = A11y;","map":null,"metadata":{},"sourceType":"script"}